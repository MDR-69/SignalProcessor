// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SignalMessages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "SignalMessages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google_public::protobuf::Descriptor* SignalLevel_descriptor_ = NULL;
const ::google_public::protobuf::internal::GeneratedMessageReflection*
  SignalLevel_reflection_ = NULL;
const ::google_public::protobuf::Descriptor* SignalInstantVal_descriptor_ = NULL;
const ::google_public::protobuf::internal::GeneratedMessageReflection*
  SignalInstantVal_reflection_ = NULL;
const ::google_public::protobuf::Descriptor* Impulse_descriptor_ = NULL;
const ::google_public::protobuf::internal::GeneratedMessageReflection*
  Impulse_reflection_ = NULL;
const ::google_public::protobuf::Descriptor* LinearFFT_descriptor_ = NULL;
const ::google_public::protobuf::internal::GeneratedMessageReflection*
  LinearFFT_reflection_ = NULL;
const ::google_public::protobuf::Descriptor* LogFFT_descriptor_ = NULL;
const ::google_public::protobuf::internal::GeneratedMessageReflection*
  LogFFT_reflection_ = NULL;
const ::google_public::protobuf::Descriptor* TimeInfo_descriptor_ = NULL;
const ::google_public::protobuf::internal::GeneratedMessageReflection*
  TimeInfo_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_SignalMessages_2eproto() {
  protobuf_AddDesc_SignalMessages_2eproto();
  const ::google_public::protobuf::FileDescriptor* file =
    ::google_public::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "SignalMessages.proto");
  GOOGLE_CHECK(file != NULL);
  SignalLevel_descriptor_ = file->message_type(0);
  static const int SignalLevel_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalLevel, signalid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalLevel, signallevel_),
  };
  SignalLevel_reflection_ =
    new ::google_public::protobuf::internal::GeneratedMessageReflection(
      SignalLevel_descriptor_,
      SignalLevel::default_instance_,
      SignalLevel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalLevel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalLevel, _unknown_fields_),
      -1,
      ::google_public::protobuf::DescriptorPool::generated_pool(),
      ::google_public::protobuf::MessageFactory::generated_factory(),
      sizeof(SignalLevel));
  SignalInstantVal_descriptor_ = file->message_type(1);
  static const int SignalInstantVal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalInstantVal, signalid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalInstantVal, signalinstantval_),
  };
  SignalInstantVal_reflection_ =
    new ::google_public::protobuf::internal::GeneratedMessageReflection(
      SignalInstantVal_descriptor_,
      SignalInstantVal::default_instance_,
      SignalInstantVal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalInstantVal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignalInstantVal, _unknown_fields_),
      -1,
      ::google_public::protobuf::DescriptorPool::generated_pool(),
      ::google_public::protobuf::MessageFactory::generated_factory(),
      sizeof(SignalInstantVal));
  Impulse_descriptor_ = file->message_type(2);
  static const int Impulse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Impulse, signalid_),
  };
  Impulse_reflection_ =
    new ::google_public::protobuf::internal::GeneratedMessageReflection(
      Impulse_descriptor_,
      Impulse::default_instance_,
      Impulse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Impulse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Impulse, _unknown_fields_),
      -1,
      ::google_public::protobuf::DescriptorPool::generated_pool(),
      ::google_public::protobuf::MessageFactory::generated_factory(),
      sizeof(Impulse));
  LinearFFT_descriptor_ = file->message_type(3);
  static const int LinearFFT_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearFFT, signalid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearFFT, fundamentalfreq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearFFT, data_),
  };
  LinearFFT_reflection_ =
    new ::google_public::protobuf::internal::GeneratedMessageReflection(
      LinearFFT_descriptor_,
      LinearFFT::default_instance_,
      LinearFFT_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearFFT, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearFFT, _unknown_fields_),
      -1,
      ::google_public::protobuf::DescriptorPool::generated_pool(),
      ::google_public::protobuf::MessageFactory::generated_factory(),
      sizeof(LinearFFT));
  LogFFT_descriptor_ = file->message_type(4);
  static const int LogFFT_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, signalid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, fundamentalfreq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band3_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band4_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band5_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band6_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band7_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band8_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band9_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band10_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band11_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, band12_),
  };
  LogFFT_reflection_ =
    new ::google_public::protobuf::internal::GeneratedMessageReflection(
      LogFFT_descriptor_,
      LogFFT::default_instance_,
      LogFFT_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogFFT, _unknown_fields_),
      -1,
      ::google_public::protobuf::DescriptorPool::generated_pool(),
      ::google_public::protobuf::MessageFactory::generated_factory(),
      sizeof(LogFFT));
  TimeInfo_descriptor_ = file->message_type(5);
  static const int TimeInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, isplaying_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, tempo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, position_),
  };
  TimeInfo_reflection_ =
    new ::google_public::protobuf::internal::GeneratedMessageReflection(
      TimeInfo_descriptor_,
      TimeInfo::default_instance_,
      TimeInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, _unknown_fields_),
      -1,
      ::google_public::protobuf::DescriptorPool::generated_pool(),
      ::google_public::protobuf::MessageFactory::generated_factory(),
      sizeof(TimeInfo));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google_public::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_SignalMessages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google_public::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignalLevel_descriptor_, &SignalLevel::default_instance());
  ::google_public::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignalInstantVal_descriptor_, &SignalInstantVal::default_instance());
  ::google_public::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Impulse_descriptor_, &Impulse::default_instance());
  ::google_public::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LinearFFT_descriptor_, &LinearFFT::default_instance());
  ::google_public::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogFFT_descriptor_, &LogFFT::default_instance());
  ::google_public::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TimeInfo_descriptor_, &TimeInfo::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_SignalMessages_2eproto() {
  delete SignalLevel::default_instance_;
  delete SignalLevel_reflection_;
  delete SignalInstantVal::default_instance_;
  delete SignalInstantVal_reflection_;
  delete Impulse::default_instance_;
  delete Impulse_reflection_;
  delete LinearFFT::default_instance_;
  delete LinearFFT_reflection_;
  delete LogFFT::default_instance_;
  delete LogFFT_reflection_;
  delete TimeInfo::default_instance_;
  delete TimeInfo_reflection_;
}

void protobuf_AddDesc_SignalMessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google_public::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024SignalMessages.proto\":\n\013SignalLevel\022\023\n"
    "\010signalID\030\001 \002(\005:\0011\022\026\n\013signalLevel\030\002 \002(\002:"
    "\0010\"D\n\020SignalInstantVal\022\023\n\010signalID\030\001 \002(\005"
    ":\0011\022\033\n\020signalInstantVal\030\002 \002(\002:\0010\"\036\n\007Impu"
    "lse\022\023\n\010signalID\030\001 \002(\005:\0011\"N\n\tLinearFFT\022\023\n"
    "\010signalID\030\001 \002(\005:\0011\022\032\n\017fundamentalFreq\030\002 "
    "\002(\002:\0010\022\020\n\004data\030\003 \003(\002B\002\020\001\"\355\001\n\006LogFFT\022\023\n\010s"
    "ignalID\030\001 \001(\005:\0011\022\027\n\017fundamentalFreq\030\002 \001("
    "\002\022\r\n\005band1\030\003 \001(\002\022\r\n\005band2\030\004 \001(\002\022\r\n\005band3"
    "\030\005 \001(\002\022\r\n\005band4\030\006 \001(\002\022\r\n\005band5\030\007 \001(\002\022\r\n\005"
    "band6\030\010 \001(\002\022\r\n\005band7\030\t \001(\002\022\r\n\005band8\030\n \001("
    "\002\022\r\n\005band9\030\013 \001(\002\022\016\n\006band10\030\014 \001(\002\022\016\n\006band"
    "11\030\r \001(\002\022\016\n\006band12\030\016 \001(\002\"K\n\010TimeInfo\022\030\n\t"
    "isPlaying\030\001 \002(\010:\005false\022\020\n\005tempo\030\002 \002(\002:\0010"
    "\022\023\n\010position\030\003 \002(\002:\0010B\020B\016SignalMessages", 599);
  ::google_public::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "SignalMessages.proto", &protobuf_RegisterTypes);
  SignalLevel::default_instance_ = new SignalLevel();
  SignalInstantVal::default_instance_ = new SignalInstantVal();
  Impulse::default_instance_ = new Impulse();
  LinearFFT::default_instance_ = new LinearFFT();
  LogFFT::default_instance_ = new LogFFT();
  TimeInfo::default_instance_ = new TimeInfo();
  SignalLevel::default_instance_->InitAsDefaultInstance();
  SignalInstantVal::default_instance_->InitAsDefaultInstance();
  Impulse::default_instance_->InitAsDefaultInstance();
  LinearFFT::default_instance_->InitAsDefaultInstance();
  LogFFT::default_instance_->InitAsDefaultInstance();
  TimeInfo::default_instance_->InitAsDefaultInstance();
  ::google_public::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_SignalMessages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_SignalMessages_2eproto {
  StaticDescriptorInitializer_SignalMessages_2eproto() {
    protobuf_AddDesc_SignalMessages_2eproto();
  }
} static_descriptor_initializer_SignalMessages_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int SignalLevel::kSignalIDFieldNumber;
const int SignalLevel::kSignalLevelFieldNumber;
#endif  // !_MSC_VER

SignalLevel::SignalLevel()
  : ::google_public::protobuf::Message() {
  SharedCtor();
}

void SignalLevel::InitAsDefaultInstance() {
}

SignalLevel::SignalLevel(const SignalLevel& from)
  : ::google_public::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SignalLevel::SharedCtor() {
  _cached_size_ = 0;
  signalid_ = 1;
  signallevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignalLevel::~SignalLevel() {
  SharedDtor();
}

void SignalLevel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SignalLevel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google_public::protobuf::Descriptor* SignalLevel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignalLevel_descriptor_;
}

const SignalLevel& SignalLevel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SignalMessages_2eproto();
  return *default_instance_;
}

SignalLevel* SignalLevel::default_instance_ = NULL;

SignalLevel* SignalLevel::New() const {
  return new SignalLevel;
}

void SignalLevel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    signalid_ = 1;
    signallevel_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignalLevel::MergePartialFromCodedStream(
    ::google_public::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google_public::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google_public::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 signalID = 1 [default = 1];
      case 1: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google_public::protobuf::int32, ::google_public::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &signalid_)));
          set_has_signalid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_signalLevel;
        break;
      }

      // required float signalLevel = 2 [default = 0];
      case 2: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_signalLevel:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &signallevel_)));
          set_has_signallevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google_public::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignalLevel::SerializeWithCachedSizes(
    ::google_public::protobuf::io::CodedOutputStream* output) const {
  // required int32 signalID = 1 [default = 1];
  if (has_signalid()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteInt32(1, this->signalid(), output);
  }

  // required float signalLevel = 2 [default = 0];
  if (has_signallevel()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(2, this->signallevel(), output);
  }

  if (!unknown_fields().empty()) {
    ::google_public::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google_public::protobuf::uint8* SignalLevel::SerializeWithCachedSizesToArray(
    ::google_public::protobuf::uint8* target) const {
  // required int32 signalID = 1 [default = 1];
  if (has_signalid()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->signalid(), target);
  }

  // required float signalLevel = 2 [default = 0];
  if (has_signallevel()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->signallevel(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google_public::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SignalLevel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 signalID = 1 [default = 1];
    if (has_signalid()) {
      total_size += 1 +
        ::google_public::protobuf::internal::WireFormatLite::Int32Size(
          this->signalid());
    }

    // required float signalLevel = 2 [default = 0];
    if (has_signallevel()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google_public::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignalLevel::MergeFrom(const ::google_public::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignalLevel* source =
    ::google_public::protobuf::internal::dynamic_cast_if_available<const SignalLevel*>(
      &from);
  if (source == NULL) {
    ::google_public::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignalLevel::MergeFrom(const SignalLevel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signalid()) {
      set_signalid(from.signalid());
    }
    if (from.has_signallevel()) {
      set_signallevel(from.signallevel());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignalLevel::CopyFrom(const ::google_public::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignalLevel::CopyFrom(const SignalLevel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignalLevel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SignalLevel::Swap(SignalLevel* other) {
  if (other != this) {
    std::swap(signalid_, other->signalid_);
    std::swap(signallevel_, other->signallevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google_public::protobuf::Metadata SignalLevel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google_public::protobuf::Metadata metadata;
  metadata.descriptor = SignalLevel_descriptor_;
  metadata.reflection = SignalLevel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SignalInstantVal::kSignalIDFieldNumber;
const int SignalInstantVal::kSignalInstantValFieldNumber;
#endif  // !_MSC_VER

SignalInstantVal::SignalInstantVal()
  : ::google_public::protobuf::Message() {
  SharedCtor();
}

void SignalInstantVal::InitAsDefaultInstance() {
}

SignalInstantVal::SignalInstantVal(const SignalInstantVal& from)
  : ::google_public::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SignalInstantVal::SharedCtor() {
  _cached_size_ = 0;
  signalid_ = 1;
  signalinstantval_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignalInstantVal::~SignalInstantVal() {
  SharedDtor();
}

void SignalInstantVal::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SignalInstantVal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google_public::protobuf::Descriptor* SignalInstantVal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignalInstantVal_descriptor_;
}

const SignalInstantVal& SignalInstantVal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SignalMessages_2eproto();
  return *default_instance_;
}

SignalInstantVal* SignalInstantVal::default_instance_ = NULL;

SignalInstantVal* SignalInstantVal::New() const {
  return new SignalInstantVal;
}

void SignalInstantVal::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    signalid_ = 1;
    signalinstantval_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignalInstantVal::MergePartialFromCodedStream(
    ::google_public::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google_public::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google_public::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 signalID = 1 [default = 1];
      case 1: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google_public::protobuf::int32, ::google_public::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &signalid_)));
          set_has_signalid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_signalInstantVal;
        break;
      }

      // required float signalInstantVal = 2 [default = 0];
      case 2: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_signalInstantVal:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &signalinstantval_)));
          set_has_signalinstantval();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google_public::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignalInstantVal::SerializeWithCachedSizes(
    ::google_public::protobuf::io::CodedOutputStream* output) const {
  // required int32 signalID = 1 [default = 1];
  if (has_signalid()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteInt32(1, this->signalid(), output);
  }

  // required float signalInstantVal = 2 [default = 0];
  if (has_signalinstantval()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(2, this->signalinstantval(), output);
  }

  if (!unknown_fields().empty()) {
    ::google_public::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google_public::protobuf::uint8* SignalInstantVal::SerializeWithCachedSizesToArray(
    ::google_public::protobuf::uint8* target) const {
  // required int32 signalID = 1 [default = 1];
  if (has_signalid()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->signalid(), target);
  }

  // required float signalInstantVal = 2 [default = 0];
  if (has_signalinstantval()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->signalinstantval(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google_public::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SignalInstantVal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 signalID = 1 [default = 1];
    if (has_signalid()) {
      total_size += 1 +
        ::google_public::protobuf::internal::WireFormatLite::Int32Size(
          this->signalid());
    }

    // required float signalInstantVal = 2 [default = 0];
    if (has_signalinstantval()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google_public::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignalInstantVal::MergeFrom(const ::google_public::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignalInstantVal* source =
    ::google_public::protobuf::internal::dynamic_cast_if_available<const SignalInstantVal*>(
      &from);
  if (source == NULL) {
    ::google_public::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignalInstantVal::MergeFrom(const SignalInstantVal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signalid()) {
      set_signalid(from.signalid());
    }
    if (from.has_signalinstantval()) {
      set_signalinstantval(from.signalinstantval());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignalInstantVal::CopyFrom(const ::google_public::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignalInstantVal::CopyFrom(const SignalInstantVal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignalInstantVal::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SignalInstantVal::Swap(SignalInstantVal* other) {
  if (other != this) {
    std::swap(signalid_, other->signalid_);
    std::swap(signalinstantval_, other->signalinstantval_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google_public::protobuf::Metadata SignalInstantVal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google_public::protobuf::Metadata metadata;
  metadata.descriptor = SignalInstantVal_descriptor_;
  metadata.reflection = SignalInstantVal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Impulse::kSignalIDFieldNumber;
#endif  // !_MSC_VER

Impulse::Impulse()
  : ::google_public::protobuf::Message() {
  SharedCtor();
}

void Impulse::InitAsDefaultInstance() {
}

Impulse::Impulse(const Impulse& from)
  : ::google_public::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Impulse::SharedCtor() {
  _cached_size_ = 0;
  signalid_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Impulse::~Impulse() {
  SharedDtor();
}

void Impulse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Impulse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google_public::protobuf::Descriptor* Impulse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Impulse_descriptor_;
}

const Impulse& Impulse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SignalMessages_2eproto();
  return *default_instance_;
}

Impulse* Impulse::default_instance_ = NULL;

Impulse* Impulse::New() const {
  return new Impulse;
}

void Impulse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    signalid_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Impulse::MergePartialFromCodedStream(
    ::google_public::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google_public::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google_public::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 signalID = 1 [default = 1];
      case 1: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google_public::protobuf::int32, ::google_public::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &signalid_)));
          set_has_signalid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google_public::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Impulse::SerializeWithCachedSizes(
    ::google_public::protobuf::io::CodedOutputStream* output) const {
  // required int32 signalID = 1 [default = 1];
  if (has_signalid()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteInt32(1, this->signalid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google_public::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google_public::protobuf::uint8* Impulse::SerializeWithCachedSizesToArray(
    ::google_public::protobuf::uint8* target) const {
  // required int32 signalID = 1 [default = 1];
  if (has_signalid()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->signalid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google_public::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Impulse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 signalID = 1 [default = 1];
    if (has_signalid()) {
      total_size += 1 +
        ::google_public::protobuf::internal::WireFormatLite::Int32Size(
          this->signalid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google_public::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Impulse::MergeFrom(const ::google_public::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Impulse* source =
    ::google_public::protobuf::internal::dynamic_cast_if_available<const Impulse*>(
      &from);
  if (source == NULL) {
    ::google_public::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Impulse::MergeFrom(const Impulse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signalid()) {
      set_signalid(from.signalid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Impulse::CopyFrom(const ::google_public::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Impulse::CopyFrom(const Impulse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Impulse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Impulse::Swap(Impulse* other) {
  if (other != this) {
    std::swap(signalid_, other->signalid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google_public::protobuf::Metadata Impulse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google_public::protobuf::Metadata metadata;
  metadata.descriptor = Impulse_descriptor_;
  metadata.reflection = Impulse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LinearFFT::kSignalIDFieldNumber;
const int LinearFFT::kFundamentalFreqFieldNumber;
const int LinearFFT::kDataFieldNumber;
#endif  // !_MSC_VER

LinearFFT::LinearFFT()
  : ::google_public::protobuf::Message() {
  SharedCtor();
}

void LinearFFT::InitAsDefaultInstance() {
}

LinearFFT::LinearFFT(const LinearFFT& from)
  : ::google_public::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LinearFFT::SharedCtor() {
  _cached_size_ = 0;
  signalid_ = 1;
  fundamentalfreq_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LinearFFT::~LinearFFT() {
  SharedDtor();
}

void LinearFFT::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LinearFFT::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google_public::protobuf::Descriptor* LinearFFT::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LinearFFT_descriptor_;
}

const LinearFFT& LinearFFT::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SignalMessages_2eproto();
  return *default_instance_;
}

LinearFFT* LinearFFT::default_instance_ = NULL;

LinearFFT* LinearFFT::New() const {
  return new LinearFFT;
}

void LinearFFT::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    signalid_ = 1;
    fundamentalfreq_ = 0;
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LinearFFT::MergePartialFromCodedStream(
    ::google_public::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google_public::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google_public::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 signalID = 1 [default = 1];
      case 1: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google_public::protobuf::int32, ::google_public::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &signalid_)));
          set_has_signalid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_fundamentalFreq;
        break;
      }

      // required float fundamentalFreq = 2 [default = 0];
      case 2: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fundamentalFreq:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fundamentalfreq_)));
          set_has_fundamentalfreq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // repeated float data = 3 [packed = true];
      case 3: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_data())));
        } else if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google_public::protobuf::internal::WireFormatLite::
                      WIRETYPE_FIXED32) {
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 26, input, this->mutable_data())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google_public::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LinearFFT::SerializeWithCachedSizes(
    ::google_public::protobuf::io::CodedOutputStream* output) const {
  // required int32 signalID = 1 [default = 1];
  if (has_signalid()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteInt32(1, this->signalid(), output);
  }

  // required float fundamentalFreq = 2 [default = 0];
  if (has_fundamentalfreq()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(2, this->fundamentalfreq(), output);
  }

  // repeated float data = 3 [packed = true];
  if (this->data_size() > 0) {
    ::google_public::protobuf::internal::WireFormatLite::WriteTag(3, ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_data_cached_byte_size_);
  }
  for (int i = 0; i < this->data_size(); i++) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloatNoTag(
      this->data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google_public::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google_public::protobuf::uint8* LinearFFT::SerializeWithCachedSizesToArray(
    ::google_public::protobuf::uint8* target) const {
  // required int32 signalID = 1 [default = 1];
  if (has_signalid()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->signalid(), target);
  }

  // required float fundamentalFreq = 2 [default = 0];
  if (has_fundamentalfreq()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->fundamentalfreq(), target);
  }

  // repeated float data = 3 [packed = true];
  if (this->data_size() > 0) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteTagToArray(
      3,
      ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google_public::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _data_cached_byte_size_, target);
  }
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google_public::protobuf::internal::WireFormatLite::
      WriteFloatNoTagToArray(this->data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google_public::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LinearFFT::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 signalID = 1 [default = 1];
    if (has_signalid()) {
      total_size += 1 +
        ::google_public::protobuf::internal::WireFormatLite::Int32Size(
          this->signalid());
    }

    // required float fundamentalFreq = 2 [default = 0];
    if (has_fundamentalfreq()) {
      total_size += 1 + 4;
    }

  }
  // repeated float data = 3 [packed = true];
  {
    int data_size = 0;
    data_size = 4 * this->data_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google_public::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _data_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google_public::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LinearFFT::MergeFrom(const ::google_public::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LinearFFT* source =
    ::google_public::protobuf::internal::dynamic_cast_if_available<const LinearFFT*>(
      &from);
  if (source == NULL) {
    ::google_public::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LinearFFT::MergeFrom(const LinearFFT& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signalid()) {
      set_signalid(from.signalid());
    }
    if (from.has_fundamentalfreq()) {
      set_fundamentalfreq(from.fundamentalfreq());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LinearFFT::CopyFrom(const ::google_public::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LinearFFT::CopyFrom(const LinearFFT& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearFFT::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void LinearFFT::Swap(LinearFFT* other) {
  if (other != this) {
    std::swap(signalid_, other->signalid_);
    std::swap(fundamentalfreq_, other->fundamentalfreq_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google_public::protobuf::Metadata LinearFFT::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google_public::protobuf::Metadata metadata;
  metadata.descriptor = LinearFFT_descriptor_;
  metadata.reflection = LinearFFT_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogFFT::kSignalIDFieldNumber;
const int LogFFT::kFundamentalFreqFieldNumber;
const int LogFFT::kBand1FieldNumber;
const int LogFFT::kBand2FieldNumber;
const int LogFFT::kBand3FieldNumber;
const int LogFFT::kBand4FieldNumber;
const int LogFFT::kBand5FieldNumber;
const int LogFFT::kBand6FieldNumber;
const int LogFFT::kBand7FieldNumber;
const int LogFFT::kBand8FieldNumber;
const int LogFFT::kBand9FieldNumber;
const int LogFFT::kBand10FieldNumber;
const int LogFFT::kBand11FieldNumber;
const int LogFFT::kBand12FieldNumber;
#endif  // !_MSC_VER

LogFFT::LogFFT()
  : ::google_public::protobuf::Message() {
  SharedCtor();
}

void LogFFT::InitAsDefaultInstance() {
}

LogFFT::LogFFT(const LogFFT& from)
  : ::google_public::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogFFT::SharedCtor() {
  _cached_size_ = 0;
  signalid_ = 1;
  fundamentalfreq_ = 0;
  band1_ = 0;
  band2_ = 0;
  band3_ = 0;
  band4_ = 0;
  band5_ = 0;
  band6_ = 0;
  band7_ = 0;
  band8_ = 0;
  band9_ = 0;
  band10_ = 0;
  band11_ = 0;
  band12_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogFFT::~LogFFT() {
  SharedDtor();
}

void LogFFT::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LogFFT::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google_public::protobuf::Descriptor* LogFFT::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogFFT_descriptor_;
}

const LogFFT& LogFFT::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SignalMessages_2eproto();
  return *default_instance_;
}

LogFFT* LogFFT::default_instance_ = NULL;

LogFFT* LogFFT::New() const {
  return new LogFFT;
}

void LogFFT::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    signalid_ = 1;
    fundamentalfreq_ = 0;
    band1_ = 0;
    band2_ = 0;
    band3_ = 0;
    band4_ = 0;
    band5_ = 0;
    band6_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    band7_ = 0;
    band8_ = 0;
    band9_ = 0;
    band10_ = 0;
    band11_ = 0;
    band12_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogFFT::MergePartialFromCodedStream(
    ::google_public::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google_public::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google_public::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 signalID = 1 [default = 1];
      case 1: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google_public::protobuf::int32, ::google_public::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &signalid_)));
          set_has_signalid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_fundamentalFreq;
        break;
      }

      // optional float fundamentalFreq = 2;
      case 2: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fundamentalFreq:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fundamentalfreq_)));
          set_has_fundamentalfreq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_band1;
        break;
      }

      // optional float band1 = 3;
      case 3: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band1:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band1_)));
          set_has_band1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_band2;
        break;
      }

      // optional float band2 = 4;
      case 4: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band2:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band2_)));
          set_has_band2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_band3;
        break;
      }

      // optional float band3 = 5;
      case 5: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band3:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band3_)));
          set_has_band3();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_band4;
        break;
      }

      // optional float band4 = 6;
      case 6: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band4:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band4_)));
          set_has_band4();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_band5;
        break;
      }

      // optional float band5 = 7;
      case 7: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band5:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band5_)));
          set_has_band5();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_band6;
        break;
      }

      // optional float band6 = 8;
      case 8: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band6:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band6_)));
          set_has_band6();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_band7;
        break;
      }

      // optional float band7 = 9;
      case 9: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band7:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band7_)));
          set_has_band7();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_band8;
        break;
      }

      // optional float band8 = 10;
      case 10: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band8:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band8_)));
          set_has_band8();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_band9;
        break;
      }

      // optional float band9 = 11;
      case 11: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band9:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band9_)));
          set_has_band9();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_band10;
        break;
      }

      // optional float band10 = 12;
      case 12: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band10:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band10_)));
          set_has_band10();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_band11;
        break;
      }

      // optional float band11 = 13;
      case 13: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band11:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band11_)));
          set_has_band11();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(117)) goto parse_band12;
        break;
      }

      // optional float band12 = 14;
      case 14: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_band12:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &band12_)));
          set_has_band12();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google_public::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogFFT::SerializeWithCachedSizes(
    ::google_public::protobuf::io::CodedOutputStream* output) const {
  // optional int32 signalID = 1 [default = 1];
  if (has_signalid()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteInt32(1, this->signalid(), output);
  }

  // optional float fundamentalFreq = 2;
  if (has_fundamentalfreq()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(2, this->fundamentalfreq(), output);
  }

  // optional float band1 = 3;
  if (has_band1()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(3, this->band1(), output);
  }

  // optional float band2 = 4;
  if (has_band2()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(4, this->band2(), output);
  }

  // optional float band3 = 5;
  if (has_band3()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(5, this->band3(), output);
  }

  // optional float band4 = 6;
  if (has_band4()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(6, this->band4(), output);
  }

  // optional float band5 = 7;
  if (has_band5()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(7, this->band5(), output);
  }

  // optional float band6 = 8;
  if (has_band6()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(8, this->band6(), output);
  }

  // optional float band7 = 9;
  if (has_band7()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(9, this->band7(), output);
  }

  // optional float band8 = 10;
  if (has_band8()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(10, this->band8(), output);
  }

  // optional float band9 = 11;
  if (has_band9()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(11, this->band9(), output);
  }

  // optional float band10 = 12;
  if (has_band10()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(12, this->band10(), output);
  }

  // optional float band11 = 13;
  if (has_band11()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(13, this->band11(), output);
  }

  // optional float band12 = 14;
  if (has_band12()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(14, this->band12(), output);
  }

  if (!unknown_fields().empty()) {
    ::google_public::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google_public::protobuf::uint8* LogFFT::SerializeWithCachedSizesToArray(
    ::google_public::protobuf::uint8* target) const {
  // optional int32 signalID = 1 [default = 1];
  if (has_signalid()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->signalid(), target);
  }

  // optional float fundamentalFreq = 2;
  if (has_fundamentalfreq()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->fundamentalfreq(), target);
  }

  // optional float band1 = 3;
  if (has_band1()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->band1(), target);
  }

  // optional float band2 = 4;
  if (has_band2()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->band2(), target);
  }

  // optional float band3 = 5;
  if (has_band3()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->band3(), target);
  }

  // optional float band4 = 6;
  if (has_band4()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->band4(), target);
  }

  // optional float band5 = 7;
  if (has_band5()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->band5(), target);
  }

  // optional float band6 = 8;
  if (has_band6()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->band6(), target);
  }

  // optional float band7 = 9;
  if (has_band7()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->band7(), target);
  }

  // optional float band8 = 10;
  if (has_band8()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->band8(), target);
  }

  // optional float band9 = 11;
  if (has_band9()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->band9(), target);
  }

  // optional float band10 = 12;
  if (has_band10()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->band10(), target);
  }

  // optional float band11 = 13;
  if (has_band11()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->band11(), target);
  }

  // optional float band12 = 14;
  if (has_band12()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->band12(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google_public::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogFFT::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 signalID = 1 [default = 1];
    if (has_signalid()) {
      total_size += 1 +
        ::google_public::protobuf::internal::WireFormatLite::Int32Size(
          this->signalid());
    }

    // optional float fundamentalFreq = 2;
    if (has_fundamentalfreq()) {
      total_size += 1 + 4;
    }

    // optional float band1 = 3;
    if (has_band1()) {
      total_size += 1 + 4;
    }

    // optional float band2 = 4;
    if (has_band2()) {
      total_size += 1 + 4;
    }

    // optional float band3 = 5;
    if (has_band3()) {
      total_size += 1 + 4;
    }

    // optional float band4 = 6;
    if (has_band4()) {
      total_size += 1 + 4;
    }

    // optional float band5 = 7;
    if (has_band5()) {
      total_size += 1 + 4;
    }

    // optional float band6 = 8;
    if (has_band6()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float band7 = 9;
    if (has_band7()) {
      total_size += 1 + 4;
    }

    // optional float band8 = 10;
    if (has_band8()) {
      total_size += 1 + 4;
    }

    // optional float band9 = 11;
    if (has_band9()) {
      total_size += 1 + 4;
    }

    // optional float band10 = 12;
    if (has_band10()) {
      total_size += 1 + 4;
    }

    // optional float band11 = 13;
    if (has_band11()) {
      total_size += 1 + 4;
    }

    // optional float band12 = 14;
    if (has_band12()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google_public::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogFFT::MergeFrom(const ::google_public::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogFFT* source =
    ::google_public::protobuf::internal::dynamic_cast_if_available<const LogFFT*>(
      &from);
  if (source == NULL) {
    ::google_public::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogFFT::MergeFrom(const LogFFT& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signalid()) {
      set_signalid(from.signalid());
    }
    if (from.has_fundamentalfreq()) {
      set_fundamentalfreq(from.fundamentalfreq());
    }
    if (from.has_band1()) {
      set_band1(from.band1());
    }
    if (from.has_band2()) {
      set_band2(from.band2());
    }
    if (from.has_band3()) {
      set_band3(from.band3());
    }
    if (from.has_band4()) {
      set_band4(from.band4());
    }
    if (from.has_band5()) {
      set_band5(from.band5());
    }
    if (from.has_band6()) {
      set_band6(from.band6());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_band7()) {
      set_band7(from.band7());
    }
    if (from.has_band8()) {
      set_band8(from.band8());
    }
    if (from.has_band9()) {
      set_band9(from.band9());
    }
    if (from.has_band10()) {
      set_band10(from.band10());
    }
    if (from.has_band11()) {
      set_band11(from.band11());
    }
    if (from.has_band12()) {
      set_band12(from.band12());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogFFT::CopyFrom(const ::google_public::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogFFT::CopyFrom(const LogFFT& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogFFT::IsInitialized() const {

  return true;
}

void LogFFT::Swap(LogFFT* other) {
  if (other != this) {
    std::swap(signalid_, other->signalid_);
    std::swap(fundamentalfreq_, other->fundamentalfreq_);
    std::swap(band1_, other->band1_);
    std::swap(band2_, other->band2_);
    std::swap(band3_, other->band3_);
    std::swap(band4_, other->band4_);
    std::swap(band5_, other->band5_);
    std::swap(band6_, other->band6_);
    std::swap(band7_, other->band7_);
    std::swap(band8_, other->band8_);
    std::swap(band9_, other->band9_);
    std::swap(band10_, other->band10_);
    std::swap(band11_, other->band11_);
    std::swap(band12_, other->band12_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google_public::protobuf::Metadata LogFFT::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google_public::protobuf::Metadata metadata;
  metadata.descriptor = LogFFT_descriptor_;
  metadata.reflection = LogFFT_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TimeInfo::kIsPlayingFieldNumber;
const int TimeInfo::kTempoFieldNumber;
const int TimeInfo::kPositionFieldNumber;
#endif  // !_MSC_VER

TimeInfo::TimeInfo()
  : ::google_public::protobuf::Message() {
  SharedCtor();
}

void TimeInfo::InitAsDefaultInstance() {
}

TimeInfo::TimeInfo(const TimeInfo& from)
  : ::google_public::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TimeInfo::SharedCtor() {
  _cached_size_ = 0;
  isplaying_ = false;
  tempo_ = 0;
  position_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TimeInfo::~TimeInfo() {
  SharedDtor();
}

void TimeInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TimeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google_public::protobuf::Descriptor* TimeInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TimeInfo_descriptor_;
}

const TimeInfo& TimeInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_SignalMessages_2eproto();
  return *default_instance_;
}

TimeInfo* TimeInfo::default_instance_ = NULL;

TimeInfo* TimeInfo::New() const {
  return new TimeInfo;
}

void TimeInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    isplaying_ = false;
    tempo_ = 0;
    position_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TimeInfo::MergePartialFromCodedStream(
    ::google_public::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google_public::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google_public::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool isPlaying = 1 [default = false];
      case 1: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google_public::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isplaying_)));
          set_has_isplaying();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_tempo;
        break;
      }

      // required float tempo = 2 [default = 0];
      case 2: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_tempo:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &tempo_)));
          set_has_tempo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_position;
        break;
      }

      // required float position = 3 [default = 0];
      case 3: {
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_position:
          DO_((::google_public::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google_public::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &position_)));
          set_has_position();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google_public::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google_public::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google_public::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TimeInfo::SerializeWithCachedSizes(
    ::google_public::protobuf::io::CodedOutputStream* output) const {
  // required bool isPlaying = 1 [default = false];
  if (has_isplaying()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteBool(1, this->isplaying(), output);
  }

  // required float tempo = 2 [default = 0];
  if (has_tempo()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(2, this->tempo(), output);
  }

  // required float position = 3 [default = 0];
  if (has_position()) {
    ::google_public::protobuf::internal::WireFormatLite::WriteFloat(3, this->position(), output);
  }

  if (!unknown_fields().empty()) {
    ::google_public::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google_public::protobuf::uint8* TimeInfo::SerializeWithCachedSizesToArray(
    ::google_public::protobuf::uint8* target) const {
  // required bool isPlaying = 1 [default = false];
  if (has_isplaying()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->isplaying(), target);
  }

  // required float tempo = 2 [default = 0];
  if (has_tempo()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->tempo(), target);
  }

  // required float position = 3 [default = 0];
  if (has_position()) {
    target = ::google_public::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->position(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google_public::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TimeInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool isPlaying = 1 [default = false];
    if (has_isplaying()) {
      total_size += 1 + 1;
    }

    // required float tempo = 2 [default = 0];
    if (has_tempo()) {
      total_size += 1 + 4;
    }

    // required float position = 3 [default = 0];
    if (has_position()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google_public::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TimeInfo::MergeFrom(const ::google_public::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TimeInfo* source =
    ::google_public::protobuf::internal::dynamic_cast_if_available<const TimeInfo*>(
      &from);
  if (source == NULL) {
    ::google_public::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TimeInfo::MergeFrom(const TimeInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_isplaying()) {
      set_isplaying(from.isplaying());
    }
    if (from.has_tempo()) {
      set_tempo(from.tempo());
    }
    if (from.has_position()) {
      set_position(from.position());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TimeInfo::CopyFrom(const ::google_public::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimeInfo::CopyFrom(const TimeInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void TimeInfo::Swap(TimeInfo* other) {
  if (other != this) {
    std::swap(isplaying_, other->isplaying_);
    std::swap(tempo_, other->tempo_);
    std::swap(position_, other->position_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google_public::protobuf::Metadata TimeInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google_public::protobuf::Metadata metadata;
  metadata.descriptor = TimeInfo_descriptor_;
  metadata.reflection = TimeInfo_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
